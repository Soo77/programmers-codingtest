Ch9-1 Object 클래스
- 모든 클래스의 최고 조상. 오직 11개의 메서드만을 가지고 있다.
(iv나 cv 없다.)
- notify(), wait()등은 쓰레드와 관련된 메서드이다.

protected Object clone() : 객체 자신의 복사본을 반환한다.
public boolean equals(Object obj) : 객체 자신과 객체 obj가 같은 객체인지 알려준다.(같으면 true)
protected void finalize() : 객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출된다. 이 때 수행되어야하는
코드가 있을 때 오버라이딩 한다. (거의 사용안함)
public Class getClass() : 객체 자신의 클래스 정보를 담고 있는 Class인스턴스를 반환한다.
							(Class객체에는 (예시)Hello class에 대한 정보가 다 담겨있다. iv 개수, 조상이 누구고, 
							메서드가 몇개있고, 생성자가 뭐가있고 등등. 즉, 설계도 객체. 어떤 객체에 대해서 getClass를 호출하면, 
							설계도 객체를 준다. 이 설계도 객체를 통해서 1. 객체를 생성 가능 2. 객체에 대한 정보 얻음) 

Ch9-2 equals(Object obj)
- 객체 자신(this)과 주어진 객체(obj)를 비교한다. 같으면 true, 다르면 false.
- Object클래스의 equals()는 객체의 주소를 비교(참조변수 값 비교)
주소가 아닌 value를 비교하려면 Object의 equals()를 오버라이딩해서 사용.

Ch9-3 equals(Object obj)의 오버라이딩
- 인스턴스 변수(iv)의 값을 비교하도록 equals()를 오버라이딩해야한다.
(cv: 객체마다 공통, iv: 객체마다 다름)



Ch9-4 hashCode()
- 객체의 해시코드(hash code)를 반환하는 메서드
(해시코드는 정수값이고, 해싱 알고리즘에서 사용한다.)
- Object 클래스의 hashCode()는 객체의 주소를 int 로 변환해서 반환
- equals()를 오버라이딩 하면, hashCode()도 오버라이딩 해야 한다.
  equals()의 결과가 true인 두 객체의 해시코드는 같아야하기 때문*
- System.identityHashCode(Object obj)는 Object 클래스의 hashCode()와 동일
(그런데 equals는 주소가 아닌 iv를 가지고 비교하도록 오버라이딩 할때는 해시코드도 오버라이딩 하므로
객체마다 다른 해시코드 반환하는 기능이 없어짐.)

Ch9-5~6 toString(), toString()의 오버라이딩
- toString(): 객체를 문자열(String)으로 변환하기 위한 메서드
Object 클래스의 toString()은 
Card@19e0bfd
클래스이름@Integer.toHexString(hashCode())
 
Ch9-7 String 클래스 <- 문자열을 다루기 위한 클래스
- String클래스 = 데이터(char[]) + 메서드(문자열 관련)
- 내용을 변경할 수 없는 불변(immutable) 클래스
	a = a+b (ab) ab가 a에 들어가는게 아니라 완전히 새로운 문자열이 만들어짐.
	a가 새로만들어짐 ab 주소를 가리키게됨.
- 덧셈 연산자(+)를 이용한 문자열 결합은 성능이 떨어짐. (계속 새로운 문자열이 만들어지니까)
	문자열의 결합이나 변경이 잦다면, 내용을 변경가능한 StringBuffer를 사용
	
Ch9-8 문자열의 비교
- String str = "abc"; 와 String str= new String("abc");의 비교
	문자열 리터럴로 문자열을 만들면 하나의 문자열을 여러 참조변수가 공유한다.
	new 연산자를 사용하면 항상 새로운 문자열이 만들어진다.
	
	문자열은 내용변경이 불가능하니 여러 참조변수가 공유해도 별 문제가 안된다.
	굳이 같은 내용의 문자열을 여러번 만들 필요가 없다.
	
Ch9-9 문자열 리터럴
- 문자열 리터럴은 프로그램 실행시 자동으로 생성된다. (constant pool에 저장)